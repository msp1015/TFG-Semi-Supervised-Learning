\apendice{Plan de Proyecto Software}

\section{Introducción}
Este apéndice tiene como propósito proporcionar una visión detallada del proceso de planificación y estudio de viabilidad que ha sido fundamental en el desarrollo del proyecto de software presentado. A través de una metodología ágil, se han abordado las diferentes tareas a lo largo del tiempo, asegurando un seguimiento exhaustivo y adaptativo de cada fase del proyecto.
Además, este documento explora en profundidad el estudio de viabilidad realizado, abarcando aspectos tanto legales como económicos. El análisis legal es crucial para asegurar que el proyecto cumpla con todas las normativas y legislaciones aplicables, minimizando así posibles riesgos legales. Por otro lado, el estudio económico proporciona una evaluación detallada de la viabilidad financiera del proyecto, incluyendo estimaciones de costes y beneficios.

\section{Planificación temporal}
Como se explica en la sección 4 de la memoria, el marco de desarrollo de trabajo a seguir es Scrum, salvando las distancias con el número de personas que suele haber en un contexto habitual, ya que únicamente habrá un desarrollador.
El proyecto se elige antes de empezar el curso, únicamente para poder informarse y leer articulos relacionados con el tema del aprendizaje semi supervisado. Al inicio con sprint más largos y a medida que se avanza en el desarrollo los sprints se reducen a una o dos semanas de duración, realizando una reunión al inicio de cada uno.


\subsection{Sprint 1}
Este sprint corresponde a las fechas entre el 7 de noviembre y el 18 de diciembre. Se comienza con una reunión en la que se establecen las siguientes tareas:\\
\begin{itemize}
	\item Crear un repositorio en GitHub donde poder subir los cambios del proyecto, más concretamente, la plantilla de documentación inicial para ir familiarizándose con \LaTeX.
	\item También se manda terminar de leer el artículo~\cite{Engelen:semi-supervised} y se asigna una nueva lectura acerca de ensembles~\cite{ensembles}. Esto es necesario ya que de entre los algoritmos a implementar, alguno de ellos será un ensemble. Concepto que se desconocía antes de iniciar la lectura.
	\item Encontrar un programa adecuado para el seguimiento del proyecto que soporte Scrum.
\end{itemize}

El repositorio se crea siguiendo la plantilla de documentación ya creada en 2016 y publicada en Github, se puede acceder a través del enlace \url{https://github.com/msp1015/TFG-Semi-Supervised-Learning}. Para poder empezar a familiarizarse con \LaTeX{} es necesario instalar los programas necesarios en el equipo local. Se prueban TeXstudio y TeXworks como editores, y por gusto y comodidad se elige TeXstudio como editor de archivos. También se instala MiKTex, que es una distribución de \TeX/\LaTeX{} para sistemas operativos Windows.
Se continua con la lectura establecida, adquiriendo conceptos de ensembles, estos son, ¿Qué es el boosting? ¿Qué es el bagging? ¿Qué posibilidades hay de combinar varios modelos? entre otros.

En cuanto al programa utilizado para el seguimiento de las tareas y sprints, se prueban varios como Zenhub, Jira y Taiga. El primero era la mejor opción dado su relacion con Github, pero al ser de pago se descarta. Entre Jira y Taiga se elige la segunda por su accesibilidad, los numerosos problemas de Jira hacen que la plataforma de Taiga sea la elegida.
Esta herramienta se explica en el apartado cuatro de la memoria, pero su sencillez y el hecho de poder comunicarse con GitHub hacen facil su uso. Aun asi, queda abierto a cambiar debido a que no es la herramienta que ofrece mas posibilidades.
\subsection{Sprint 2}
Sprint correspondiente a las fechas entre el 18 de noviembre y el 15 de enero. Se inicia con una reunión previa para establecer las tareas: 
\begin{itemize}
	\item Finalizar la lectura de~\cite{ensembles}.
	\item Comenzar la documentación con conceptos teóricos acerca del aprendizaje automático vistos hasta el momento.
	\item  Aprender a usar el entorno de flask en python.
\end{itemize}

La lectura y documentacion se realiza durante el periodo de vacaciones, mientras que el aprendizaje de flask, se lleva a cabo con la ayuda de la asignatura cursada de Diseño y Mantenimiento del Software, en la que se realiza una web que se implementa con este \textit{framework}.

Se encuentra una aplicación llamada Zappier, la cual permite construir triggers entre aplicaciones. En este caso sirve para que cada vez que se cree una \textit{issue} en github, se cree como historia de usuario en el product backlog de Taiga, donde despues se gestionará independientemente. Esta aplicación está de nuevo explicada en el apartado 4 de la memoria. 
\subsection{Sprint 3}
Sprint correspondiente a las fechas entre el 15 de enero y el 1 de febrero. Se tiene una reunión previa para asignar las tareas de: 
\begin{itemize}
	\item Lectura del algoritmo Co-Forest~\cite{IEEE:CoForest} y su pseudocódigo.
	\item Búsqueda de trabajos relacionados para coger ideas propias para el proyecto.
	\item Continuar documentando los conceptos teóricos (ensembles, Co-Forest).
\end{itemize}

En este periodo se completa la lectura del artículo del algoritmo Co-Forest y del apartado del trabajo de Patricia y sus estudios relacionados con este algoritmo. El principal estudio que realiza consiste en resolver un error del pseudocódigo, donde un valor podía coger el valor cero cuando se utiliza como divisor. Mediante tres propuestas, se inicializa este valor con diferentes operaciones y se muestran varias gráficas para poder evaluar la mejor opción.

Se realiza una búsqueda amplia de aplicaciones web para visualización de algoritmos, apuntando y explicando las más interesantes en el apartado 6 de la memoria.
Se realiza la implementación de la técnica de Scrum en el apartado 4 de la memoria.
Se deja para sprint posteriores la documentación del CoForest, ya que puede que los conceptos adquiridos no sean los correctos hasta que no se haga su implementación y se vean los resultados.

\subsection{Sprint 4}
Sprint correspondiente a las fechas entre el 1 de febrero y el 14 de febrero. Las tareas asignadas para este sprint son:
\begin{itemize}
	\item Primera implementacion del algoritmo Co-Forest, basado en~\cite{IEEE:CoForest}.
	\item Evaluar esta primera implementación.
	\item Actualizar documentación, incluyendo este apartado.
	\item Continuar con la búsqueda de trabajos relacionados en la web.
\end{itemize}

Para la primera tarea, es importante comentar que se utiliza como referencia el pseudocódigo del articulo mencionado pero también la implementación de Patricia Hernando~\cite{TFG:Patricia}. 
Una vez se tiene la primera implementación del algoritmo, se compara con el algoritmo de Patricia, el cual se considera una solución muy buena como ensemble.
El estudio realizado se explica mejor en el apartado de aspectos relevantes de la memoria, pero cabe mencionar que los primeros resultados no son muy fiables, lo que hace pensar que algo está mal implementado.
Además de la búsqueda de páginas anteriores, se encuentra una muy buena opción: \url{https://ml-visualizer.herokuapp.com/}. Esta página tiene algo diferente, ya que permite configurar y ver el resultado del algoritmo en la misma ventana. Este será uno de los objetivos en la web.

\subsection{Sprint 5}
Sprint que corresponde a las dos semanas siguientes, se asignan las tareas:
\begin{itemize}
	\item Corregir fallos en la implementación del Co-Forest.
	\item Comenzar a mirar el código correspondiente a la web del trabajo de David, el cual podría resultar interesante para el futuro.
	\item Evaluar correctamente el Co-Forest.
	\item Continuar con la documentación.
\end{itemize}

Se muestra al tutor la página encontrada, se acuerda que puede ser una buena idea para la web, pero antes hay que familiarizarse con el entorno de la web y su código. Esto incluye decidir si las llamadas a la web, una vez ejecutas el algoritmo, se realizan de una en una, devolviendo un gráfico en cada iteración, o una sola llamada que calcule todo el algoritmo y que reciba un diccionario con toda la información necesaria para su representación. Se resuelven dudas del algoritmo Coforest, como la necesidad del uso de \textit{random state} para tener un estudio reproducible. El estudio sigue teniendo bastantes diferencias en comparación con el de Patricia, lo que hace pensar de nuevo que algo en el código no esta bien programado.

\subsection{Sprint 6}
Se inicia con una reunión el 7 de marzo, surge un cambio de planes, dejando las siguientes tareas por hacer:
\begin{itemize}
	\item Continuar documentación (Co-Forest, trabajos relacionados)
	\item El trabajo será una versión 2.0 del desarrollo de David.
	\item Esto implica tener que familiarizarse con el trabajo de David, su estructura, web, etc.
	\item Corregir estilo de programación. Estandarizar mediante la guía de estilo de Python, PEP8~\cite{PEP8}.
	\item Revisar Co-Forest debido a que la comparación con el de Patricia no es del todo buena.
	
\end{itemize} 
La decisión de continuar el trabajo de David se da ya que la idea original para esta implementación iba a ser prácticamente igual. Por ello, se aprovecha la base de este trabajo, sobretodo el de la web, ya que los algoritmos serán diferentes. La idea es seguir con un estilo propio en la configuración de la web, pero todo sobre la plantilla ya creada por David. 
En cuanto al código implementado hasta el momento, se considera que está bastante desordenado, sin documentar y sin seguir una guía de estilos. Por ello, se establece el idioma español para nombrar a todas las variables, se documentan todos los métodos de la manera correspondiente en python, y con la auyda de librerias como \textit{pylint} y \textit{mypy} se sigue la guía de estilo PEP8.
El error que se estaba cometiendo en cuanto a la implementación del Co-Forest estaba en el calculo del error, ya que uno de los parámetros (los índices de los datos de entrenamiento que se usan en cada árbol) se estaba repitiendo en cada ejecución, cuando cada árbol debería tener los suyos. Es decir, el error se estaba calculando de manera incorrecta. Una vez corregido esto, el algoritmo se considera eficiente.

\subsection{Sprint 7}
Este Sprint es aún más reducido debido a las condiciones dadas, correspondiente entre los días 14 y 20 de marzo. Se utiliza para avanzar en todas aquellas tareas retrasadas, asignando las tareas:
\begin{itemize}
	\item Documentación de conceptos teóricos: tanto teoría de ensembles como el propio algoritmo Co-Forest.
	\item Documentación de trabajos relacionados.
	\item Documentación de aspectos relevantes.
	\item Documentación de anexos.
	\item Prototipo de ventana pensada para la configuración del algoritmo.
	
\end{itemize}
Sin mucha más explicación, se avanza todo lo que se puede en la documentación y, una vez visto y entendido la mayor parte del proyecto web de David, se empieza el prototipo de una nueva ventana.

\subsection{Sprint 8}
Debido a que el calendario corresponde con la semana santa, este Sprint corresponde entre los días 20 de marzo y 4 de abril. Se asignan las siguientes tareas:
 \begin{itemize}
 	\item Continuación de toda la documentación del Sprint anterior.
 	\item Ver tutoriales de JavaScript y de BootStrap
 	\item Introducir correctamente el Co-Forest en la web
 	\item Investigar la manera en la que se pasan los parametros de ejecución del algoritmo (JSON).
 	
 \end{itemize}
En cuanto a los tutoriales, se siguen los de la web \url{https://www.w3schools.com/} y también algún video de YouTube. HTML y css son dos lenguajes que se pueden ir aprendiendo sobre la marcha, pero javascript puede ser complicado de entender sin unos conceptos previos, y más cuando se trata de un proyecto complejo. Por esto se dedica gran parte del tiempo a aprender las bases del lenguaje. 
En cuanto a la web, se integra gran parte del Co-Forest, permitiendo realizar todos los pasos hasta la visualización, donde surge un error de servidor.
Para conseguir la comunicación entre la ejecución del algoritmo y su visualización se realizará siguiendo la misma técnica que David, para ello primero hay que comprender todo lo que recoge del propio algoritmo. Se decide fijarse en el algoritmo Democratic Co-Learning por su gran parecido con el Co-Forest.

Además de todo esto, aparece un error en la parte de la gestión de usuarios, no permitiendo registrar ni logear usuarios. Esto se debe a algún problema con el método que se utiliza para la encriptación de las contraseñas, el cual se deja a resolver para el siguiente sprint.

\subsection{Sprint 9}
De nuevo se vuelven con las reuniones semanales, estableciendo las siguientes tareas:
 \begin{itemize}
	\item Introducir la parte de visualización del co-forest en la web.
	\item Modificar el código del Co-Forest para tener el JSON.
	
\end{itemize}

Ambas tareas están relacionadas, ya que para poder ver una visualizacion final, es necesario almacenar todos los datos de la ejecución. La tarea de conseguir la visualizacion consiste más bien en corregir el error mencionado anteriormente. Ya que un error 400 no da muchas pistas de donde puede estar el error, se hace un seguimiento de todo el proceso. Esto conlleva ir mostrando por consola los diferentes valores y resultados. Finalmente se localiza el error en la forma en la que se denominan los \textit{div} en los formularios. Para el caso del Co-Forest, se usa lo que ya existía de los árboles de decisión. Esto hace que no haya necesidad de crear un \textit{div} para seleccionador el clasificador. Sin embargo, para aprovechar el código de David, es necesario definir uno y darle el mismo nombre en los diferentes formularios para que funcione.
El JSON se consigue basandose de nuevo en el Democratic Co-Learning. Puede que se guarden los mismos datos, pero la manera de recogerlos es distinta en cada algoritmo.

Se resuelve el error del sprint anterior de la parte de gestión de usuarios. Una vez aislado el error se ve que lo que falla es un método de una librería utilizada para encriptar contraseñas, lo que da a pensar que alguno de los parámetros pasados deja de ser compatible con la versión de la biblioteca actual. Efectivamente la versión de este proyecto de la biblioteca \textit{werkzeug} no coincidía con la del trabajo base. En concreto el parámetro incompatible que se le estaba pasando a este método es la propia contraseña encriptada, la cual empezaba por \textit{sha256}. La nueva versión del método establece que para usar \textit{sha256} el texto debe empezar por \textit{pbkdf2:sha256}, por lo tanto se cambia esta opción y también el \textit{hash} definido para el administrador al inciar la aplicación.

\subsection{Sprint 10}
Del 11 de abril al 18 de abril, se establecen las siguientes tareas de cara al siguiente sprint:
 \begin{itemize}
	\item Actualizar documentación.
	\item Visualizar resultados del Co-Forest en la web
	\item Crear un gráfico de tarta como tooltip en los datos.
\end{itemize}
Se consigue la visualización del Co-Forest completa reutilizando gran parte del código de los otros algoritmos, dando pie también a posibles cambios futuros en la visualización. Finalmente se determina que el gráfico de tarta no es la mejor manera de representar este tipo de soluciones y se mantiene el estilo original. Esto tiene la desventaja de que en el Co-Forest existen muchos más clasificadores y en ocasiones provoca un \textit{tooltip} mucho más grande y que se sale de la pantalla. 

Además se hacen pequeños cambios, por ejemplo se considera que es mejor dejar una opción de la etiqueta o clase por defecto al configurar cualquier algoritmo. Esto es así porque cuando tratamos con archivos dedicados a aprendizaje automático, la mayoría de ellos tienen su etiqueta en la última columna. Por lo tanto se mostrará por defecto esta columna como clase o etiqueta en vez de dejarlo vacío. También se añade una opción que permite desmarcar y marcar todas las opciones (clasificadores) en el gráfico de estadísticas específicas, esto surge como idea después de implementar el Co-Forest, ya que si el usuario selecciona muchos árboles de decisión, está bien que pueda quitar o añadir  todos de golpe.

\subsection{Sprint 11}
Sprint correspondiente a los días entre el 18 y el 25 de abril, en la reunión se establecen las siguientes tareas:
 \begin{itemize}
	\item Finalizar tareas pendiente del Co-Forest. Estas son:
	\begin{itemize}
		\item Arreglar última iteración ya que no aporta información
		\item Quitar parámetro de inicialización de pesos ya que realmente no afecta demasiado.
		\item Cambiar la visualización del \textit{tooltip} para que se pueda ver toda la información.
	\end{itemize}
	\item Leer documentación de construcción de grafos.
	\item Elegir biblioteca de \textit{python} para la construcción de grafos.
\end{itemize}

Este Sprint se utiliza sobretodo para leer e investigar acerca de los métodos transductivos o basados en grafos. Más concretamente se manda leer el artículo del algoritmo \textit{GBILI}, que será uno de ellos a implementar en cuánto a la construcción del grafo y el artículo de \textit{Local and Global Consistency (LGC)} como algoritmo de inferencia de etiquetas. En la memoria se especifican las características de ambos algoritmos.
 
Se realiza un estudio para la elección de una biblioteca en el uso de grafos, que se puede encontrar en los aspectos relevantes. Finalmente se decide utilizar \textit{NetworkX} por su facilidad de uso y aprendizaje.

En cuanto a los arreglos del Co-Forest, se realizan las dos primeras tareas marcadas y se deja para más adelante cambiar la visualización del \textit{tooltip}. El problema con la última iteración provenía de la manera en la que se devolvía el número de iteraciones. Los datos se guardaban correctamente, pero teniendo en cuenta que las iteraciones comienzan en 0, se estaba devolviendo un valor mayor del que debería. 

\subsection{Sprint 12}
Sprint correspondiente a la siguiente semana entre el 25 de abril y el 2 de mayo. Se mandan las siguientes tareas:
\begin{itemize}
	\item Implementar algoritmos: tanto el \textit{GBILI} como el \textit{LGC}.
	\item Documentar los conceptos de cada algoritmo y los aspectos relevantes en su implementación.
\end{itemize}

En este sprint no hay mucho detalle que comentar ya que se trata de implementar el algoritmo. Finalmente no se utiliza la librería \textit{NetworkX} para almacenar los datos del grafo, sino que se utiliza para su visualización. La visualización en este caso ayuda a ver si realmente el grafo se está construyendo siguiendo los pasos establecidos y si tienen sentido o no. Por ejemplo, si se colorean todos los nodos que son etiquetados, se podrá saber si la conexión basada en estos nodos es correcta o no.

Finalmente no se consigue implementar ambos algoritmos de forma definitiva pero sí se llega a una buena aproximación. El aspecto a destacar es que de la forma en que se implementa el algoritmo \textit{LGC} realmente no aprovecha la disposición física final del grafo, sino su matriz de distancias original. Se va con esta premisa a la siguiente reunión para tener en cuenta un posible cambio.

\subsection{Sprint 13}
Corresponde a los días entre el 2 y el 9 de mayo. Se comentan las siguientes tareas a realizar:
\begin{itemize}
	\item Depurar el código del algoritmo \textit{GBILI}.
	\item Depurar el código del algoritmo \textit{LGC}.
\end{itemize}

Se trata de finalizar ambos algoritmos para poder empezar su integración con la web.

El resumen de las correciones en el \textit{GBILI} (todas ellas comentadas en la sección 5 de la memoria) es: el grafo es no dirigido por lo que se deben almacenar enlaces en ambas direcciones, el pseudocódigo se puede interpretar erróneamente y provocar fallos al almacenar las estructuras de datos necesarias y por último, la visualización debe ser con el grafo ordenado para que tenga sentido las nuevas conexiones.

En cuanto a la inferencia se debe tener en cuenta la conexión entre nodos del grafo mediante una matriz de afinidad binaria (1 si hay conexión, 0 en caso contrario). Se resuelve así el problema de que el algoritmo no utilizaba los enlaces del grafo, pero surge uno nuevo. Uno de los pasos de este algoritmo hace la suma por filas de esta nueva matriz de afinidad, consiguiendo así valores enteros en su diagonal. La posibilidad de que haya ceros en esta matriz hace que se produzcan indeterminaciones en operaciones posteriores, por lo que se debe plantear una solución a esto.

Se consigue tener el algoritmo \textit{GBILI} bien implementado, pero al inferir etiquetas los resultados no son los esperados con la nueva matriz de afinidad.

Se empieza a integrar en la web una nueva opción para seleccionar la visualización de grafos. La idea es tener una única opción y combinar la construcción del grafo junto con la fase de inferencia de etiquetas. A estas alturas se planea hacer dos algoritmos de construcción de grafos y dos de inferencia (ya teniendo uno de cada).

\subsection{Sprint 14}
Correspondiente a los días entre el 9 y el 16 de mayo. Se comentan las siguientes tareas:
\begin{itemize}
	\item Corregir definitivamente ambos algoritmos (\textit{LGC} en especial).
	\item Integrar en la web, con la visualización por fases.
\end{itemize}

En la reunión se dan las pautas finales para implementar definitivamente el algoritmo \textit{LGC}. Se estaba utilizando la matriz de afinidad definida por unos y ceros, pero también el primer paso del algoritmo definido en~\cite{LGC}, que calcula otra matriz de afinidad distinta. Con la eliminación de este paso y el uso de regularización para evitar el problema de las divisiones entre 0, se da por finalizado la implementación del algoritmo \textit{Local and Global Consistency}.

La documentación lleva gran parte del tiempo de este sprint, pero se consigue ponerse al día con la memoria. Por ello la web sufre poco cambio y lo que cambia es el código con integración de métodos necesarios para los grafos.

\subsection{Sprint 15}
Sprint correspondiente a los días entre el 16 y el 23 de mayo. En la reunión se definen las tareas:
\begin{itemize}
	\item Realizar estudio del funcionamiento de los algoritmos \textit{GBILI} y \textit{LGC} y documentarlo.
	\item Lectura e implementación del algoritmo RGCLI.
	\item Documentación del anexo B: Especificación de Requisitos.
\end{itemize}

Para finalizar con la parte de los algoritmos \textit{GBILI} y \textit{LGC} se decide realizar un estudio de su utilización conjunta, con varios valores en sus parámetros. Para ello, con ayuda de un mapa de calor, se realizan varias ejecuciones con distintos valores en sus parámetros, consiguiendo así localizar que parámetros afectan más y qué valores en los parámetros producen mejores resultados.

Se decide que el último algoritmo a implementar sea el \textit{RGCLI}~\cite{rgcli}. Es una mejora del \textit{GBILI} por lo que la lectura y la comprensión suponen menos problema que el anterior. Se implementa una primera versión muy parecida al pseudocódigo original.

Con respecto a la documentación se extienden los requisitos ya existentes en la documentación del trabajo anterior. No hay muchos requisitos ni funcionalidades nuevas pero se considera que los definidos son muy generales y por eso se decide hacer una lista más detallada. Además, se deciden poner los casos de uso generales que entran dentro de los objetivos, entre ellos: dar opción al usuario de acceder a documentación del algoritmo, visualizar tabla de datos al cargar archivos y también visualizar una tabla de resultados finales, con la clasificación de cada dato de entrada. 

\subsection{Sprint 16}
Sprint correspondiente a los días entre el 23 y el 30 de mayo. En la reunión se definen las tareas:
\begin{itemize}
	\item Integración en la web de los algoritmos.
	\item Traducir textos generados hasta el momento.
\end{itemize}

En este tiempo el trabajo no sufre gran cambio. Mientras se intenta integrar finalmente la visualización de los grafos en la web final, se realiza un proyecto en paralelo únicamente dedicado a la visualización de grafos en una web. Para ello se intenta simular una ejecución real en este subproyecto, generando un \textit{json} con los resultados de la ejecución, como se hacía con el \textit{Co-Forest} y después visualizando, con ayuda de la librería \textit{d3.js}, los grafos en cada paso. Esto lleva bastante tiempo debido a la inexperiencia con el uso de simulaciones en \textit{javascript} y a la complejidad de representar diferentes pasos dentro de un grafo.

\subsection{Sprint 17}
Sprint correspondiente a los días entre el 30 de mayo y el 6 de junio. Se decide llevar el trabajo a segunda convocatoria (julio) y se definen las siguientes tareas:
\begin{itemize}
	\item Corregir \textit{RGCLI}.
	\item Continuar la integración en la web de los algoritmos.
	\item Cambiar página de inicio de la web.
	\item Corregir y continuar parte de anexos y memoria.
\end{itemize}

En este periodo se intenta trasladar todo el proyecto realizado aparte a la web real. Para ello se debe realizar gran parte de código específico para grafos, ya que muchos de los métodos anteriores no sirven. Buscando reutilizar la mayor parte del código, hay situaciones en las que la lógica debe ser separada entre métodos inductivos y métodos basados en grafos, pensando también en facilitar nuevas implementaciones futuras.
Se consigue poder ejecutar tanto los algoritmos \textit{GBILI} como el \textit{RGCLI} junto con el \textit{LGC} y se visualizan los grafos paso por paso.

Con respecto al \textit{RGCLI}, se cambia su implementación para que no haga su ejecución con hilos y facilite la recogida de datos para representarlos.

La página de inicio de la web sufre un cambio visual. Los contenedores o \textit{cards} que contienen los iconos de los algoritmos y que permiten seleccionarlos, se decide hacerlos de manera horizontal, además de incluir una explicación introductoria al algoritmo y permitir acceder a la documentación de cada algoritmo (en las mismas \textit{cards}). Esto se decide así ya que de la manera en la que estaba hecho, un usuario que entra por primera vez, puede no conocer nada del algoritmo, provocando que tenga que seleccionar un algoritmo y un fichero para poder leer su explicación en la parte de configuración. Además se generan y eligen los iconos definitivos para los algoritmos basados en grafos y para el \textit{Co-Forest}.


\subsection{Sprint 18}
Sprint correspondiente a los días entre el 6 de junio y 20 de junio. Se definen las siguientes tareas:
\begin{itemize}
	\item Finalizar parte de configuración y visualización de grafos.
	\item Pantalla de subida de archivos.
	\item Crear pseudocódigos específicos para la web.
	\item Corregir y documentar parte de la memoria.
	\item Finalizar con los anexos A, B y C.
\end{itemize}

El inicio de este Sprint se utiliza para ponerse al día con la documentación, tanto de la memoria como los anexos. Para ello, se decide realizar ya todas las secciones y corregir algunas de ellas. Por ejemplo, la parte de los conceptos teóricos basados en grafos, se considera que es una parte muy importante del trabajo, y como la documentación estaba basada en un artículo el cual hace de introducción hacia estos métodos, se decide usar otro artículo como complemento, una \textit{review} hecha en 2021 que contiene detalles más extensos y renovados~\cite{GSSL:review}.

En la visualización, se pretende corregir: poner las imágenes definitivas de los pseudocódigos de cada algoritmo nuevo, conseguir que en la configuración la parte de teoría cambie dinámicamente según quiera el usuario ver la fase de construcción de grafos o la fase de inferencia y por último completar el paso a paso de los algoritmos para que de forma visual se vea qué parte está ejecutando.

Además, se realiza el planteamiento que surgió en los primeros sprints de generar un resumen de los datos cada vez que se sube un archivo. Se añade también la funcionalidad de seleccionar un fichero por defecto, en lugar de tener que descargarlo.

Al inicio de este periodo se descubre \textit{Lighthouse}, una herramienta que permite evaluar el rendimiento de una web. Proporciona tanto métricas como consejos de implementación para mejorar el rendimiento. Se pretende usar en lo que queda de tiempo para cumplir con los consejos y tener buenas métricas tanto en dispositivo móvil como en escritorio.

\subsection{Sprint 19}
Sprint correspondiente a los días entre el 20 de junio y 4 de julio. Se definen las siguientes tareas:
\begin{itemize}
	\item Depurar y finalizar la visualización de grafos.
	\item Revisar todas las traducciones.
	\item Desplegar la web en un servidor.
	\item Testear web con \textit{Selenium IDE}.
	\item Comprobar la integración completa con la gestión de usuarios.
	\item Finalizar la memoria.
	\item Revisar anexos del sprint anterior y finalizar los que faltan.
\end{itemize}

Este tiempo se utiliza principalmente para depurar la web y corregir errores. Primero se realiza el despliegue y después se van corrigiendo los errores que se van encontrando (mayormente traducciones y gestión de usuarios). 

Una vez se considera que la web es definitiva y que no se van a realizar más cambios, se decide hacer pruebas con \textit{Selenium IDE} a la vez que se documentan los caso de prueba.

Primero se revisa y finaliza la memoria con los nuevos cambios y por último se realizan los anexos.

\subsection{Sprint 20}
Sprint correspondiente a los días entre el 4 de julio y la fecha de entrega. Se utiliza para finalizar toda la documentación, tanto de memoria y anexos como del código. Se realizan los últimos cambios y se comprueba que todo está correcto.

\section{Estudio de viabilidad}
El estudio de viabilidad de un proyecto de software es una evaluación integral que analiza la posibilidad de llevar a cabo un proyecto considerando factores económicos, técnicos y legales. Este estudio ayuda a determinar si el proyecto es rentable, cumple con las regulaciones legales y es técnicamente factible. En este contexto, se abordarán específicamente la viabilidad económica, que analiza costes y beneficios, y la viabilidad legal, que examina el cumplimiento de normativas y leyes aplicables.

\subsection{Viabilidad económica}
La viabilidad económica en el desarrollo de software evalúa si los costes de desarrollo, mantenimiento e implementación son superados por los beneficios proyectados, abarcando tanto los costes como los beneficios potenciales.

\subsubsection{Costes}
Los costes en el desarrollo de software son los recursos económicos necesarios para llevar a cabo el proyecto, incluyendo todos los gastos relacionados con el personal, las herramientas y equipos necesarios, y otros gastos indirectos.

\paragraph{Costes de empleados}

Los costes de empleados incluyen salarios y otros gastos asociados con la contratación y retención de personal cualificado, como desarrolladores, diseñadores, gestores de proyectos y personal de soporte. En este caso solo hay un desarrollador que tiene todas las funciones anteriores y un tutor que actúa como soporte y gestor del proyecto. Teniendo en cuenta que el salario mínimo de un programador \textit{junior} en España es de 23\,666€ actualizado a día 10 de junio de 2024~\cite{salario}, que un trabajador con jornada completa de forma anual trabaja alrededor de 1\,820 horas (consultado en~\cite{jornadaAnual}) y que el tiempo  empleado en el trabajo ha sido una media de 16 horas a la semana (contando días laborales y fin de semanas) durante 9 meses. El salario del desarrollador sale a:
\begin{center}
	$ \frac{23\,666\frac{\text{€}}{\text{año}}}{1\,820\frac{\text{horas}}{\text{año}}} \times (9\text{meses} \times 4\frac{\text{semanas}}{\text{mes}} \times 16\frac{\text{horas}}{\text{semana}}) = 7\,489.89\text{€} \approx 832.21\frac{\text{€}}{mes}$
\end{center}

En el caso del tutor académico se estima un tiempo medio de $1.5$ horas a la semana. Si de nuevo buscamos en~\cite{salarioProfe}, suponemos un sueldo base promedio de 34\,401€. Con las mismas suposiciones que antes, se calcula:
\begin{center}
	$ \frac{34\,401\frac{\text{€}}{\text{año}}}{1\,820\frac{\text{horas}}{\text{año}}} \times (9\text{meses} \times 4\frac{\text{semanas}}{\text{mes}} \times 1.5\frac{\text{horas}}{\text{semana}}) = 1\,020.69\text{€} \approx 113.4\frac{\text{€}}{mes}$
\end{center}

Contando con que solo dos personas conforman el equipo, en la tabla \ref{tabla:salarios} se pueden ver los pagos definitivos después de aplicar los impuestos que ha de pagar la empresa~\cite{impuestos}. Esto es un porcentaje de contingencias, de desempleo, de FOGASA y de formación profesional, respectivamente con el orden visto en la fórmula:

\[
\frac{\text{Sueldo}}{1-(0.236+0.055+0.002+0.006)}
\]

\begin{table}[H]
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{lrr}
			\toprule
			\textbf{Empleado}                               & \textbf{Salario bruto (€/mes)}       & \textbf{Coste de la empresa (€/mes)}      \\ \midrule
			Desarrollador: Mario Sanz Pérez               & 832,21                    & 1\,187,17                      \\
			Supervisor: Álvar Arnaiz González            & 113,4                      & 161,77                       \\
			\midrule
			\textbf{Total}                          & 945,61                    &  1\,384,94                     \\ \midrule
			\textbf{Total 9 meses}                  & 8\,510,49                    & 12\,140,46                      \\ \bottomrule
			
		\end{tabular}%
	}
	\caption{Salarios brutos y costes después de impuestos}
	\label{tabla:salarios}
\end{table}

\paragraph{Costes de \textit{hardware}:} Para realizar este proyecto el equipo necesitado ha sido el reflejado en la tabla~\ref{tabla:hw}. Las especificaciones del ordenador portátil, con una vida útil\footnote{La vida útil de un dispositivo es el período durante el cual se espera que funcione de manera eficiente antes de que sea necesario reemplazarlo debido al desgaste o a la obsolescencia tecnológica.} de 4 años, son: marca \textit{Asus VivoBook} con procesador \textit{Intel Core i7-1065G7}, 8GB de memoria RAM y 512 GB de SSD. Como ayuda para poder agilizar el trabajo también se utiliza un monitor \textit{Acer KA240H}. Y por úlitmo, para el despliegue de la aplicación, se utiliza el servidor más pequeño de Microsot Azure con vida útil de 1 año y un precio de $5.0881€$ al mes~\cite{azure:plans}.

\begin{table}[H]
	\centering
	\begin{tabular}{lrr}
		\toprule
		\textbf{Activo}      & \textbf{Coste total (€)}      & \textbf{Coste amortizado (€)}      \\ \midrule
		Ordenador portátil     & 829,00                    & 207,25                      \\
		Monitor ayuda			& 105,99 						& 26,5							\\
		Servidor             & 61,06                    &  45,8                     \\ \midrule
		\textbf{Total}       & 1\,057,11                   & 279,55                      \\ \midrule
	\end{tabular}
	\caption{Costes para el \textit{hardware} del proyecto}
	\label{tabla:hw}
\end{table}

\paragraph{Costes de \textit{software}:} Para poder desarrollar el proyecto han sido necesarios varios programas cuya adquisición y licencias son gratuitos. Algunas de las excepciones son: \textit{Microsoft 365}, \textit{Github Copilot} y el dominio de la página web. El coste y su amortización se ven reflejados en la tabla~\ref{tabla:sw}, donde se ha considerado una vida útil de 1 año por cada activo (correspondiente al tiempo de pago).

\begin{table}[H]
	\centering
	\begin{tabular}{lrr}
		\toprule
		\textbf{Activo}      & \textbf{Coste total (€)}      & \textbf{Coste amortizado (€)}      \\ \midrule
		Microsoft 365     & 69                    & 51,75                      \\
		Github Copilot			& 228 						& 171							\\
		Dominio web             & 10,98                    & 8,24                     \\ \midrule
		\textbf{Total}       & 348,75                   & 230,99                      \\ \midrule
	\end{tabular}
	\caption{Costes para el \textit{software} del proyecto}
	\label{tabla:sw}
\end{table}

\paragraph{Costes adicionales:} Además de los costes mencionados anteriormente, existen otros costes adicionales que deben considerarse. Estos incluyen la impresión y encuadernación de la documentación, así como otros costes generales de vida. 

Para la impresión y encuadernación de la documentación del proyecto, se estima un coste de 25€. Los costes generales de vida, que abarcan el uso de servicios básicos como electricidad e internet durante el desarrollo del proyecto, se estiman en 100€.

En la tabla~\ref{tabla:costes_totales} se presenta un resumen de los costes totales del proyecto, incluyendo los costes de empleados, hardware, software y otros costes adicionales.

\begin{table}[H]
    \centering
    \begin{tabular}{lrr}
        \toprule
        \textbf{Concepto}      & \textbf{Coste Total (€)} \\ \midrule
        Costes de empleados     & 12\,140,46                      \\
        Costes de \textit{hardware} & 279,55                       \\
        Costes de \textit{software} & 230,99                       \\
        Costes adicionales      & 125                         \\ \midrule
        \textbf{Coste Total}    & 12\,776,00                      \\ \bottomrule
    \end{tabular}
    \caption{Resumen de los costes totales del proyecto}
    \label{tabla:costes_totales}
\end{table}

\subsubsection{Beneficios}
Los beneficios de este proyecto no se miden en términos monetarios directos, dado que el objetivo principal de la web desarrollada es educativo. A continuación, se detallan los principales beneficios cualitativos y cuantitativos del proyecto.

\begin{itemize}
    \item Accesibilidad global a recursos educativos.
    \item Mejora de la educación y el aprendizaje de los usuarios.
    \item Desarrollo de habilidades técnicas y de gestión para el desarrollador.
    \item Impacto positivo en la comunidad educativa.
    \item Potencial para futuras expansiones y colaboraciones.
\end{itemize}

\subsection{Viabilidad legal}
La viabilidad legal de un proyecto de software se refiere a la evaluación y aseguramiento de que el proyecto cumple con todas las leyes, regulaciones y licencias pertinentes. Esto incluye la revisión de las licencias de software utilizadas, la protección de la propiedad intelectual, y el cumplimiento de las normativas de privacidad y seguridad de datos. Es fundamental para evitar conflictos legales y asegurar que el software pueda ser utilizado, distribuido y modificado de manera legal.

En este proyecto, se ha optado por utilizar la licencia BSD 3-Clause (\url{https://opensource.org/license/bsd-3-clause}), ya que el trabajo base realizado por David~\cite{TFG:David} sobre el que se desarrolla este proyecto utiliza esta misma licencia. La licencia BSD 3-Clause es una licencia de software libre y permisiva que ofrece ciertas libertades y responsabilidades tanto para los desarrolladores como para los usuarios. Sus principales características son:

\begin{itemize}
	\item Permite el uso comercial y privado del software.
	\item Permite la modificación y distribución del software.
	\item Requiere la inclusión de la licencia original en todas las copias distribuidas.
	\item Prohíbe el uso de nombres de los contribuidores para promocionar productos derivados sin permiso.

\end{itemize}

Esta elección de licencia asegura que el proyecto se mantenga en línea con los términos y condiciones del trabajo base.

\subsubsection{Bibliotecas Utilizadas}

En este proyecto se utilizan diversas bibliotecas, cada una con su propia versión y licencia, todas ellas compatibles con la licencia BSD 3-Clause. En la tabla~\ref{tabla:librerias} se muestran las bibliotecas utilizadas, sus versiones y sus licencias, junto con una breve descripción de cada una.

\begin{table}
	
	\begin{tabular}{lllp{6.5cm}}
		\toprule
    \textbf{Librería} & \textbf{Versión} & \textbf{Licencia} & \textbf{Descripción} \\ 
    \midrule
    D3 & 7.8.4 & ISC & Biblioteca para manipular documentos y crear gráficos.\\
    Bootstrap & 5.2.3 & MIT & Framework para diseño \textit{responsive}.\\
    DataTables & 1.10.21 & MIT & \textit{Plugin} de jQuery para tablas HTML interactivas.\\
    jQuery & 3.5.1 & MIT & Biblioteca de JavaScript que simplifica el manejo del DOM.\\
    Babel & 2.14.0 & BSD & Herramientas para la internacionalización. \\ 
    Flask & 3.0.2 & BSD & Framework para aplicaciones web. \\ 
    flask-babel & 4.0.0 & BSD & Extensión para Flask que agrega soporte para i18n. \\ 
    Flask-Login & 0.6.3 & MIT & Manejo de sesiones de usuario para Flask. \\ 
    Flask-SQLAlchemy & 3.1.1 & BSD & Extensión que añade soporte para SQLAlchemy a Flask. \\ 
    Flask-WTF & 1.2.1 & BSD & Soporte para formularios en Flask. \\ 
    gunicorn & 21.2.0 & MIT & Servidor HTTP WSGI para aplicaciones Python. \\ 
    imbalanced-learn & 0.12.0 & MIT & Herramientas para el aprendizaje en conjuntos de datos desbalanceados. \\ 
    matplotlib & 3.8.2 & PSF & Biblioteca para la creación de gráficos en Python. \\ 
    mypy & 1.9.0 & MIT & Verificador de tipos para Python. \\ 
    mypy-extensions & 1.0.0 & MIT & Extensiones para mypy. \\ 
    numpy & 1.26.3 & BSD & Paquete para la computación científica con Python. \\ 
    pandas & 2.2.0 & BSD & Biblioteca para el análisis y manipulación de datos. \\ 
    pylint & 3.1.0 & GPL & Herramienta para la detección de errores y malas prácticas en Python. \\  
    scikit-learn & 1.4.0 & BSD & Herramientas para el análisis de datos y minería de datos. \\ 
    scipy & 1.12.0 & BSD & Biblioteca para matemáticas, ciencias y ingeniería. \\ 
    SQLAlchemy & 2.0.28 & MIT & Kit de herramientas SQL para Python. \\  
    Werkzeug & 3.0.1 & BSD & Biblioteca WSGI para desarrollo web. \\ 
    WTForms & 3.1.2 & BSD & Biblioteca de formularios para aplicaciones web en Python. \\ 
    \bottomrule
	\end{tabular}
    \caption{Librerías utilizadas, versiones y licencias}
	\label{tabla:librerias}
\end{table}
